#!/bin/sh

me=namke
case $# in
    0) printf >&2 '%s: Makefile is not give\n' $me
       exit 2
esac
make=$1
shift

t=/tmp/nmake.$$
trap 'rm $t; exit 1' 1 2 3 14 15

awk -v me=$me -v make="$make" '
BEGIN {
    cat(make)
}

function cat(file, rc, line) {
    for (;;) {
        rc = getline < file
        if (rc == 1) {
	    if ($0 ~ /[:] .*\.dir$/)
		continue
	    replace("$(WRK)/ap.mfer: $(WRK)/main.o $(WRK)/$L; mkdir -p $(WRK) && $(LINK) $(LDFLAGS) $(WRK)/main.o $(WRK)/$L -o $@",
		    "ap.mfer: main.o $L; $(LINK) $(LDFLAGS) main.obj $L /Fo$@")
	    sub(/\.o/, ".obj")
            replace("L = libaphros_static.a", "L = libaphros_static.lib")
            replace("$(WRK)/main.o ", "$(WRK)/main.obj ")
	    replace("CXX = g++", "CXX = cl")
	    replace("CC = c99", "CC = cl")
	    replace("-o ", "/Fo")
	    replace("-std=c++14", "/std:c++14 /permissive /EHsc -DM_PI=3.141592653589793")
	    replace(" -O2 -g", " /O2 /Zi /nologo")
            replace("$(SRC)/util/gitgen.cpp:; $(SRC)/gitrev $@",
		    "$(SRC)/util'\\\\'gitgen.cpp: ..'\\\\'make'\\\\'gitgen.win.cpp; copy ..'\\\\'make'\\\\'gitgen.win.cpp $@")
            replace("$(WRK)/$L: $O; mkdir -p $(WRK) && ar rv $@ $O && ranlib $@",
		    "$L: $O; link /lib /OUT:$@ $O")
	    replace("	-rm -f $O $(WRK)/.dir $(WRK)/$L $(WRK)/$J $(WRK)/ap.mfer",
		    "	del $O $(WRK)/.dir $(WRK)/$L $(WRK)/$J $(WRK)/ap.mfer")
	    remove("$(WRK)/.dir:; mkdir -p $P && > $@")
	    remove(" -fPIC")
            remove("$(SRC)/")
            remove("$(WRK)/")
            replace("-I$(SRC)", "/I.")
            remove("mkdir -p $(WRK) && ")
            line = $0
            sub(/#.*/, "", line)
            if (sub(/^[ \t]*include[ \t]+/, "", line)) {
                sub(/[ \t]*$/, "", line)
                cat(line)
            } else
                print
        } else if (rc == 0)
            break
        else {
            printf "%s: fail to read '\''%s'\''\n", me, file | "cat >&2"
            exit(1)
        }
    }
    close(file)
}

function replace(from, to) { $0 = replace0($0, from, to) }
function replace0(s, from, to,   ans, i, size) {
    if ((size = length(from)) == 0)
        return s
    ans = ""
    for (;;) {
        if (i = index(s, from)) {
            ans = ans substr(s, 1, i - 1) to
            s = substr(s, i + size)
        } else {
            ans = ans s
            break
        }
    }
    return ans
}

function remove(s) {
    replace(s, "")
}

' > $t

if test $? -ne 0
then
    status=$?
    rm -rf $t
    exit $status
fi

cat $t
rm -f $t
