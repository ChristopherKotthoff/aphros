// Created by Petr Karnakov on 29.12.2019
// Copyright 2019 ETH Zurich

#include "approx.h"

// Retuns coefficients of interpolation scheme.
//   f = GetFace(cm, 1)
//   uf = u[cmm]*a[0] + u[cm]*a[1] + [cp]*a[2]
//    -------------------------------            //
//    |         |         |         |            //
//    |   cmm   |   cm    |f   cp   |            //
//    |         |         |         |            //
//    -------------------------------            //
// sc: scheme:
//   - fou: first order upwind
//   - cd: central differences (mean value)
//   - sou: second order upwind
//   - quick: QUICK
template <class Scal>
std::array<Scal, 3> GetCoeff(ConvSc sc) {
  std::array<Scal, 3> a;
  switch (sc) {
    case ConvSc::fou:
      a = {0., 1., 0.};
      break;
    case ConvSc::cd:
      a = {0., 0.5, 0.5};
      break;
    case ConvSc::sou:
      a = {-0.5, 1.5, 0.};
      break;
    case ConvSc::quick:
      a = {-1. / 8., 6. / 8., 3. / 8.};
      break;
    default:
      fassert(false, "GetCoeff: invalid ConvSc");
  }
  return a;
}

template <class Vect_>
class UReflectFace {
 public:
  using Vect = Vect_;
  using Scal = typename Vect::Scal;
  // v: value
  // n: normal to face
  static Scal Get(Scal v, const Vect& /*n*/) {
    return v;
  }
  static Vect Get(const Vect& v, const Vect& n) {
    return v - n * n.dot(v);
  }
};

template <class Vect_>
class UReflectCell {
 public:
  using Vect = Vect_;
  using Scal = typename Vect::Scal;
  // v: value
  // n: normal to face
  static Scal Get(Scal v, const Vect& /*n*/) {
    return v;
  }
  static Vect Get(const Vect& v, const Vect& n) {
    return v - n * (2. * n.dot(v));
  }
};

// Smoothens fieldcell with node-based averaging.
// fc: fieldcell [s]
// rep: number of iterations
// Output:
// fc: smooth field [s]
template <class T, class M>
void SmoothenNode(FieldCell<T>& fc, M& m, size_t iters) {
  auto sem = m.GetSem("smoothen");
  for (size_t iter = 0; iter < iters; ++iter) {
    if (sem()) {
      using Scal = typename M::Scal;
      // generated by gen/smooth.py
      std::array<Scal, 27> a = {
          0.015625, 0.03125,  0.015625, 0.03125,  0.0625,   0.03125, 0.015625,
          0.03125,  0.015625, 0.03125,  0.0625,   0.03125,  0.0625,  0.125,
          0.0625,   0.03125,  0.0625,   0.03125,  0.015625, 0.03125, 0.015625,
          0.03125,  0.0625,   0.03125,  0.015625, 0.03125,  0.015625};

      using MIdx = typename M::MIdx;
      auto& bc = m.GetIndexCells();
      GBlock<IdxCell, M::dim> bo(MIdx(-1), MIdx(3));
      auto fcm = fc;
      for (auto c : m.Cells()) {
        MIdx w = bc.GetMIdx(c);
        T u = 0;
        size_t i = 0;
        for (MIdx wo : bo) {
          IdxCell cn = bc.GetIdx(w + wo);
          u += fcm[cn] * a[i++];
        }
        fc[c] = u;
      }
      m.Comm(&fc);
    }
  }
}

template <class T, class M>
void CommNodes(FieldNode<T>& fn, M& m) {
  auto sem = m.GetSem("commface");
  struct {
    std::array<FieldCell<T>, M::kCellNumNeighborNodes> vfc;
  } * ctx(sem);
  auto& vfc = ctx->vfc;
  const auto range = GRange<size_t>(M::kCellNumNeighborNodes);
  if (sem("comm")) {
    for (auto q : range) {
      vfc[q].Reinit(m);
    }
    for (auto c : m.Cells()) {
      for (auto q : range) {
        vfc[q][c] = fn[m.GetNode(c, q)];
      }
    }
    for (auto q : range) {
      m.Comm(&vfc[q]);
    }
  }
  if (sem("copy")) {
    for (auto c : m.AllCells()) {
      for (auto q : range) {
        fn[m.GetNode(c, q)] = vfc[q][c];
      }
    }
  }
  if (sem()) {
    // FIXME: empty stage required to prevent destruction of ctx
    // until communication is finished in outer blocks
  }
}

// Smoothens fieldcell with node-based averaging.
// fc: fieldcell [s]
// iters: number of iterations
// Output:
// fc: smooth field [s]
template <class T, class M>
void SmoothenNode(FieldNode<T>& fn, M& m, size_t iters) {
  auto sem = m.GetSem("smoothen-node");
  for (size_t iter = 0; iter < iters; ++iter) {
    if (sem()) {
      using Scal = typename M::Scal;
      // generated by gen/smooth.py
      std::array<Scal, 27> weight = {
          0.015625, 0.03125,  0.015625, 0.03125,  0.0625,   0.03125, 0.015625,
          0.03125,  0.015625, 0.03125,  0.0625,   0.03125,  0.0625,  0.125,
          0.0625,   0.03125,  0.0625,   0.03125,  0.015625, 0.03125, 0.015625,
          0.03125,  0.0625,   0.03125,  0.015625, 0.03125,  0.015625};

      using MIdx = typename M::MIdx;
      auto& index = m.GetIndexNodes();
      GBlock<IdxCell, M::dim> stencil(MIdx(-1), MIdx(3));
      auto fnm = fn;
      for (auto n : m.Nodes()) {
        const MIdx w = index.GetMIdx(n);
        T u = 0;
        size_t i = 0;
        for (MIdx wo : stencil) {
          const IdxNode nn = index.GetIdx(w + wo);
          u += fnm[nn] * weight[i++];
        }
        fn[n] = u;
      }
    }
    if (sem.Nested()) {
      CommNodes(fn, m);
    }
  }
}

// Coefficients for approximation of gradient with polynomial.
// x: target point
// z: stencil points
// Output:
// k: such that grad(x) = sum_i (ki * f(zi))
template <class Scal>
std::vector<Scal> GetGradCoeffs(Scal x, const std::vector<Scal>& stencil) {
  // TODO: test

  size_t size = stencil.size();
  std::vector<Scal> res(size);
  for (size_t i = 0; i < size; ++i) {
    Scal a = 0;
    Scal b = 1;
    for (size_t j = 0; j < size; ++j) {
      if (j != i) {
        b *= stencil[i] - stencil[j];
        Scal t = 1;
        for (size_t k = 0; k < size; ++k) {
          if (k != i && k != j) {
            t *= x - stencil[k];
          }
        }
        a += t;
      }
    }
    res[i] = a / b;
  }
  return res;
}

// Returns GetGradCoeffs(x,z[b:]) preceeded by b zeros.
template <class Scal>
std::vector<Scal> GetGradCoeffs(Scal x, const std::vector<Scal>& z, size_t b) {
  size_t s = z.size();
  size_t ss = s - b;
  std::vector<Scal> zz(ss);
  for (size_t i = 0; i < ss; ++i) {
    zz[i] = z[b + i];
  }
  std::vector<Scal> kk = GetGradCoeffs(x, zz);
  std::vector<Scal> k(s);
  for (size_t i = 0; i < b; ++i) {
    k[i] = 0;
  }
  for (size_t i = 0; i < ss; ++i) {
    k[b + i] = kk[i];
  }
  return k;
}

// Apply boudnary conditions to halo cells
template <class T, class M>
void BcApply(FieldCell<T>& uc, const MapEmbed<BCond<T>>& me, const M& m) {
  using Vect = typename M::Vect;
  for (const auto& p : me.GetMapFace()) {
    const IdxFace f = p.first;
    const auto& bc = p.second;
    const Vect n = m.GetNormal(f);
    IdxCell cmm, cm, cp, cpp;
    GetCellColumn(m, f, bc.nci, cmm, cm, cp, cpp);
    if (bc.type == BCondType::reflect) {
      uc[cm] = UReflectCell<Vect>::Get(uc[cp], n);
      uc[cmm] = UReflectCell<Vect>::Get(uc[cpp], n);
    } else if (bc.type == BCondType::dirichlet) {
      uc[cm] = bc.val;
      uc[cmm] = bc.val;
    } else if (bc.type == BCondType::extrap) {
    }
  }
}

// Apply reflection on all boundaries
// fill: value for other types that CondFaceReflect
template <class T, class M>
void BcReflectAll(FieldCell<T>& uc, const MapEmbed<BCond<T>>& me, const M& m) {
  using Vect = typename M::Vect;

  for (const auto& p : me.GetMapFace()) {
    const IdxFace f = p.first;
    const auto& bc = p.second;
    const Vect n = m.GetNormal(f);
    IdxCell cmm, cm, cp, cpp;
    GetCellColumn(m, f, bc.nci, cmm, cm, cp, cpp);
    uc[cm] = UReflectCell<Vect>::Get(uc[cp], n);
    uc[cmm] = UReflectCell<Vect>::Get(uc[cpp], n);
  }
}
