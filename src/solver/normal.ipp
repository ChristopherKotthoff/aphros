// Created by Petr Karnakov on 30.07.2018
// Copyright 2018 ETH Zurich

#include <cmath>
#include <memory>

#include "approx.h"
#include "approx_eb.h"
#include "debug/isnan.h"
#include "geom/mesh.h"
#include "normal.h"
#include "solver.h"
#include "util/logger.h"

#if USEFLAG(AVX)
#include "util/avx.h"
#endif

template <class M_>
struct UNormal<M_>::Imp {
  static constexpr size_t dim = M::dim;

  static auto Maxmod(Scal a, Scal b) -> Scal {
    return std::abs(b) < std::abs(a) ? a : b;
  }

  // Computes normal by gradient.
  // uc: volume fraction
  // mfc: boundary conditions for volume fraction
  // Output: modified in cells with msk=1
  // fcn: normal [s]
  static void CalcNormalGrad(
      M& m, const FieldCell<Scal>& uc, const MapEmbed<BCond<Scal>>& mfc,
      FieldCell<Vect>& fcn) {
    auto gc = UEmbed<M>::AverageGradient(UEmbed<M>::Gradient(uc, mfc, m), m);
    for (auto c : m.SuCells()) {
      fcn[c] = gc[c];
    }
  }
  // Computes normal by Youngs' scheme (interpolation of gradient from nodes).
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // Output: modified in cells with fci=1, resized to m
  // fcn: normal with norm1()=1, antigradient of fcu [s]
  // XXX: uses static variables, not suspendable
  // TODO: check non-uniform mesh
  static void CalcNormalYoungs(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      FieldCell<Vect>& fcn) {
    FieldNode<Vect> fng(m, Vect(0));
    for (auto c : m.AllCells()) {
      for (size_t q = 0; q < m.GetNumNodes(c); ++q) {
        const IdxNode n = m.GetNode(c, q);
        for (size_t d = 0; d < dim; ++d) {
          fng[n][d] += ((q >> d) % 2 == 0 ? 1 : -1) * fcu[c];
        }
      }
    }
    fcn.Reinit(m);
    for (auto c : m.SuCells()) {
      if (fci[c]) {
        Vect v(0);
        for (size_t q = 0; q < m.GetNumNodes(c); ++q) {
          v += fng[m.GetNode(c, q)];
        }
        fcn[c] = -v / v.norm1();
      }
    }
  }
  // CalcNormalYoungs: optimized implementation
  static void CalcNormalYoungs1(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      FieldCell<Vect>& fcn) {
    using MIdx = typename M::MIdx;
    auto ic = m.GetIndexCells();
    auto bc = m.GetSuBlockCells();
    MIdx s = ic.GetSize();
    const size_t nx = s[0];
    const size_t ny = s[1];
    // offset
    static const size_t fx = 1;
    const size_t fy = nx;
    const size_t fz = M::dim > 2 ? ny * nx : 0;

    // index range
    const MIdx wb = bc.GetBegin() - ic.GetBegin();
    const MIdx we = bc.GetEnd() - ic.GetBegin();
    const size_t xb = wb[0], yb = wb[1], zb = M::dim > 2 ? wb[2] : 0;
    const size_t xe = we[0], ye = we[1], ze = M::dim > 2 ? we[2] : 1;

    fcn.Reinit(m);

    const Scal* pu = fcu.data();
    Vect* pn = fcn.data();
    const bool* pi = fci.data();
    for (size_t z = zb; z < ze; ++z) {
      for (size_t y = yb; y < ye; ++y) {
        for (size_t x = xb; x < xe; ++x) {
          size_t i = (z * ny + y) * nx + x;
          if (!pi[i]) {
            continue;
          }
          auto q = [i, fy, fz, pu](int dx, int dy, int dz) {
            size_t ii = i + dx * fx + dy * fy + dz * fz;
            return pu[ii];
          };
          // generated by gen/normal.py
          pn[i][0] =
              (-q(-1, -1, -1) - 2 * q(-1, -1, 0) - q(-1, -1, 1) -
               2 * q(-1, 0, -1) - 4 * q(-1, 0, 0) - 2 * q(-1, 0, 1) -
               q(-1, 1, -1) - 2 * q(-1, 1, 0) - q(-1, 1, 1) + q(1, -1, -1) +
               2 * q(1, -1, 0) + q(1, -1, 1) + 2 * q(1, 0, -1) +
               4 * q(1, 0, 0) + 2 * q(1, 0, 1) + q(1, 1, -1) + 2 * q(1, 1, 0) +
               q(1, 1, 1));
          pn[i][1] =
              (-q(-1, -1, -1) - 2 * q(-1, -1, 0) - q(-1, -1, 1) + q(-1, 1, -1) +
               2 * q(-1, 1, 0) + q(-1, 1, 1) - 2 * q(0, -1, -1) -
               4 * q(0, -1, 0) - 2 * q(0, -1, 1) + 2 * q(0, 1, -1) +
               4 * q(0, 1, 0) + 2 * q(0, 1, 1) - q(1, -1, -1) -
               2 * q(1, -1, 0) - q(1, -1, 1) + q(1, 1, -1) + 2 * q(1, 1, 0) +
               q(1, 1, 1));
          pn[i][2] =
              (-q(-1, -1, -1) + q(-1, -1, 1) - 2 * q(-1, 0, -1) +
               2 * q(-1, 0, 1) - q(-1, 1, -1) + q(-1, 1, 1) - 2 * q(0, -1, -1) +
               2 * q(0, -1, 1) - 4 * q(0, 0, -1) + 4 * q(0, 0, 1) -
               2 * q(0, 1, -1) + 2 * q(0, 1, 1) - q(1, -1, -1) + q(1, -1, 1) -
               2 * q(1, 0, -1) + 2 * q(1, 0, 1) - q(1, 1, -1) + q(1, 1, 1));

          pn[i] /= -pn[i].norm1();
        }
      }
    }
  }
#if USEFLAG(AVX)
  template <int dummy>
  static void CalcNormalYoungsAvx(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      FieldCell<Vect>& fcn, generic::Vect<Scal, 2>*) {
    CalcNormalYoungs(m, fcu, fci, fcn);
  }
  template <int dummy>
  static void CalcNormalYoungsAvx(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      FieldCell<Vect>& fcn, generic::Vect<Scal, 3>*) {
    (void)fci;
    fcn.Reinit(m, Vect(0));

    const __m256d c2 = _mm256_set1_pd(2);
    const __m256d c4 = _mm256_set1_pd(4);
    const auto& stencil = m.GetStencilOffsets();
    for (auto c : m.SuCells4()) {
      auto q = [c, &fcu, &stencil](int dx, int dy, int dz) -> const Scal* {
        return &fcu[c + stencil[(dx + 1) + (dy + 1) * 3 + (dz + 1) * 3 * 3]];
      };
      __m256d vx = _mm256_setzero_pd();
      __m256d vy = _mm256_setzero_pd();
      __m256d vz = _mm256_setzero_pd();
      auto add = [&vx, &vy, &vz, &q](const __m256d& k, int dx, int dy, int dz) {
        vx = _mm256_fmadd_pd(k, _mm256_loadu_pd(q(dx, dy, dz)), vx);
        vy = _mm256_fmadd_pd(k, _mm256_loadu_pd(q(dz, dx, dy)), vy);
        vz = _mm256_fmadd_pd(k, _mm256_loadu_pd(q(dy, dz, dx)), vz);
      };
      auto sub = [&vx, &vy, &vz, &q](const __m256d& k, int dx, int dy, int dz) {
        vx = _mm256_fnmadd_pd(k, _mm256_loadu_pd(q(dx, dy, dz)), vx);
        vy = _mm256_fnmadd_pd(k, _mm256_loadu_pd(q(dz, dx, dy)), vy);
        vz = _mm256_fnmadd_pd(k, _mm256_loadu_pd(q(dy, dz, dx)), vz);
      };
      auto diff = [&add, &sub](const __m256d& k, int dy, int dz) {
        add(k, +1, dy, dz);
        sub(k, -1, dy, dz);
      };
      auto diff1 = [&vx, &vy, &vz, &q](int dy, int dz) {
        vx = _mm256_add_pd(vx, _mm256_loadu_pd(q(+1, dy, dz)));
        vx = _mm256_sub_pd(vx, _mm256_loadu_pd(q(-1, dy, dz)));
        vy = _mm256_add_pd(vy, _mm256_loadu_pd(q(dz, +1, dy)));
        vy = _mm256_sub_pd(vy, _mm256_loadu_pd(q(dz, -1, dy)));
        vz = _mm256_add_pd(vz, _mm256_loadu_pd(q(dy, dz, +1)));
        vz = _mm256_sub_pd(vz, _mm256_loadu_pd(q(dy, dz, -1)));
      };
      diff1(+1, +1);
      diff1(+1, -1);
      diff1(-1, +1);
      diff1(-1, -1);
      diff(c2, +0, +1);
      diff(c2, +0, -1);
      diff(c2, +1, +0);
      diff(c2, -1, +0);
      diff(c4, +0, +0);

      util::Soa::Normalize1(vx, vy, vz);
      util::Soa::StoreAsAos(vx, vy, vz, (Scal*)(&fcn[c]));
    }
  }
  template <int dummy>
  static void CalcNormalYoungsAvx(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      FieldCell<Vect>& fcn, generic::Vect<Scal, 4>*) {
    CalcNormalYoungs(m, fcu, fci, fcn);
  }
  static void CalcNormalYoungsAvx(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      FieldCell<Vect>& fcn) {
    CalcNormalYoungsAvx<M::dim>(m, fcu, fci, fcn, (typename M::Vect*)(nullptr));
  }
#endif
  // Computes normal and curvature from height functions.
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // edim: effective dimension
  // ow: 1: force overwrite, 0: update only if gives steeper profile
  // Output: modified in cells with fci=1, resized to m
  // fcn: normal, antigradient of fcu, if gives steeper profile or ow=1 [s]
  static void CalcNormalHeight(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci, size_t edim,
      bool force_overwrite, FieldCell<Vect>& fcn) {
    fcn.Reinit(m);

    using Direction = typename M::Direction;
    for (auto c : m.SuCellsM()) {
      if (!fci[c]) {
        continue;
      }
      Vect best_n(0);
      size_t best_dz(0);
      for (size_t ddz : {0, 1, 2}) {
        if (ddz >= edim) {
          continue;
        }
        const Direction dz(ddz);
        const auto dx = dz.next(1);
        const auto dy = dz.next(2);

        auto hh = [&](Direction d) {
          return fcu[c + d - dz] + fcu[c + d] + fcu[c + d + dz];
        };

        Vect n;
        n[dx] = hh(dx) - hh(-dx);
        n[dy] = hh(dy) - hh(-dy);
        n[dz] = (fcu[c + dz] - fcu[c - dz] > 0 ? 2 : -2);
        n /= -n.norm1();
        if (std::abs(best_n[best_dz]) < std::abs(n[dz])) {
          best_n = n;
          best_dz = dz;
        }
      }

      if (force_overwrite ||
          std::abs(best_n[best_dz]) < std::abs(fcn[c][best_dz])) {
        fcn[c] = best_n;
      }
    }
  }
  static void UpdateNormalHeight(
      const Scal* u, Vect2& pn, size_t edim, bool force_overwrite,
      const int offset[2]) {
    Vect2 best_n(0);
    size_t best_dy = 0;
    for (size_t dy : {0, 1}) {
      if (dy >= edim) {
        continue;
      }
      const size_t dx = (dy + 1) % dim;

      auto hh = [&](int ss) { //
        return u[ss - offset[dy]] + u[ss] + u[ss + offset[dy]];
      };

      Vect2 n(0);
      n[dx] = hh(offset[dx]) - hh(-offset[dx]);
      n[dy] = (u[offset[dy]] - u[-offset[dy]] > 0 ? 2 : -2);
      n /= -n.norm1();
      if (std::abs(best_n[best_dy]) < std::abs(n[dy])) {
        best_n = n;
        best_dy = dy;
      }
    }

    if (force_overwrite || std::abs(best_n[best_dy]) < std::abs(pn[best_dy])) {
      pn = best_n;
    }
  }
  static void UpdateNormalHeight(
      const Scal* u, Vect3& pn, size_t edim, bool force_overwrite,
      const int offset[3]) {
    Vect3 best_n(0);
    size_t best_dz = 0;
    for (size_t dz : {0, 1, 2}) {
      if (dz >= edim) {
        continue;
      }
      const size_t dx = (dz + 1) % dim;
      const size_t dy = (dz + 2) % dim;

      auto hh = [&](int ss) { //
        return u[ss - offset[dz]] + u[ss] + u[ss + offset[dz]];
      };

      Vect3 n;
      n[dx] = hh(offset[dx]) - hh(-offset[dx]);
      n[dy] = hh(offset[dy]) - hh(-offset[dy]);
      n[dz] = (u[offset[dz]] - u[-offset[dz]] > 0 ? 2 : -2);
      n /= -n.norm1();
      if (std::abs(best_n[best_dz]) < std::abs(n[dz])) {
        best_n = n;
        best_dz = dz;
      }
    }

    if (force_overwrite || std::abs(best_n[best_dz]) < std::abs(pn[best_dz])) {
      pn = best_n;
    }
  }
  static void UpdateNormalHeight(
      const Scal*, Vect4&, size_t, bool, const int[4]) {
    fassert(false, "Not implemented");
  }
  // CalcNormalHeight: optimized implementation
  static void CalcNormalHeight1(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci, size_t edim,
      bool force_overwrite, FieldCell<Vect>& fcn) {
    using MIdx = typename M::MIdx;
    const auto indexc = m.GetIndexCells();
    const auto blockc_su = m.GetSuBlockCells();
    const auto s = indexc.GetSize();
    const int nx = s[0];
    const int ny = s[1];
    const int offset[] = {1, nx, (M::dim > 2 ? ny * nx : 0)};

    const MIdx wb = blockc_su.GetBegin() - indexc.GetBegin();
    const MIdx we = blockc_su.GetEnd() - indexc.GetBegin();

    fcn.Reinit(m);

    const Scal* pu = fcu.data();
    Vect* pn = fcn.data();
    const bool* pi = fci.data();
    for (int z = (M::dim > 2 ? wb[2] : 0); z < (M::dim > 2 ? we[2] : 1); ++z) {
      for (int y = wb[1]; y < we[1]; ++y) {
        for (int x = wb[0]; x < we[0]; ++x) {
          const int i = (z * ny + y) * nx + x;
          if (!pi[i]) {
            continue;
          }
          UpdateNormalHeight(&pu[i], pn[i], edim, force_overwrite, offset);
        }
      }
    }
  }
  // Computes normal by combined Young's scheme and height-functions
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // edim: effective dimension
  // Output: set to NaN if fci=0
  // fcn: normal with norm1()=1, antigradient of fcu [s]
  static void CalcNormal(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci, size_t edim,
      FieldCell<Vect>& fcn) {
    fcn.Reinit(m, Vect(GetNan<Scal>()));
#if USEFLAG(AVX)
    CalcNormalYoungsAvx(m, fcu, fci, fcn);
#else
    CalcNormalYoungs1(m, fcu, fci, fcn);
#endif
    CalcNormalHeight1(m, fcu, fci, edim, false, fcn);
  }

  // u: volume fraction, array of size 3x3
  static Vect2 GetNormalYoungs(const std::array<Scal, 9>& u) {
    auto q = [&u](int dx, int dy) {
      const int i = (dx + 1) + (dy + 1) * 3;
      return u[i];
    };

    Vect2 n;
    n[0] =
        (-q(-1, -1) - 2 * q(-1, 0) - q(-1, 1) + //
         q(1, -1) + 2 * q(1, 0) + q(1, 1));
    n[1] =
        (-q(-1, -1) + q(-1, 1) - 2 * q(0, -1) + //
         2 * q(0, 1) - q(1, -1) + q(1, 1));
    n /= -n.norm1();
    return n;
  }
  // u: volume fraction, array of size 3x3x3
  static Vect3 GetNormalYoungs(const std::array<Scal, 27>& u) {
    auto q = [&u](int dx, int dy, int dz) {
      const int i = (dx + 1) + (dy + 1) * 3 + (dz + 1) * 9;
      return u[i];
    };

    Vect3 n;
    // generated by gen/normal.py
    n[0] = (1.0 / 32.0) *
           (-q(-1, -1, -1) - 2 * q(-1, -1, 0) - q(-1, -1, 1) -
            2 * q(-1, 0, -1) - 4 * q(-1, 0, 0) - 2 * q(-1, 0, 1) -
            q(-1, 1, -1) - 2 * q(-1, 1, 0) - q(-1, 1, 1) + q(1, -1, -1) +
            2 * q(1, -1, 0) + q(1, -1, 1) + 2 * q(1, 0, -1) + 4 * q(1, 0, 0) +
            2 * q(1, 0, 1) + q(1, 1, -1) + 2 * q(1, 1, 0) + q(1, 1, 1));
    n[1] = (1.0 / 32.0) *
           (-q(-1, -1, -1) - 2 * q(-1, -1, 0) - q(-1, -1, 1) + q(-1, 1, -1) +
            2 * q(-1, 1, 0) + q(-1, 1, 1) - 2 * q(0, -1, -1) - 4 * q(0, -1, 0) -
            2 * q(0, -1, 1) + 2 * q(0, 1, -1) + 4 * q(0, 1, 0) +
            2 * q(0, 1, 1) - q(1, -1, -1) - 2 * q(1, -1, 0) - q(1, -1, 1) +
            q(1, 1, -1) + 2 * q(1, 1, 0) + q(1, 1, 1));
    n[2] = (1.0 / 32.0) *
           (-q(-1, -1, -1) + q(-1, -1, 1) - 2 * q(-1, 0, -1) + 2 * q(-1, 0, 1) -
            q(-1, 1, -1) + q(-1, 1, 1) - 2 * q(0, -1, -1) + 2 * q(0, -1, 1) -
            4 * q(0, 0, -1) + 4 * q(0, 0, 1) - 2 * q(0, 1, -1) +
            2 * q(0, 1, 1) - q(1, -1, -1) + q(1, -1, 1) - 2 * q(1, 0, -1) +
            2 * q(1, 0, 1) - q(1, 1, -1) + q(1, 1, 1));

    n /= -n.norm1();
    return n;
  }
  static Vect4 GetNormalYoungs(const std::array<Scal, 81>&) {
    fassert(false, "Not implemented");
    return Vect4(0);
  }
  // u: volume fractions in a 3x3 stencil
  // n: guess for normal, updated if heights give steeper estimate
  static void GetNormalHeight(const std::array<Scal, 9>& u, Vect2& n) {
    const int w = 3;
    const int offset[] = {1, w};
    UpdateNormalHeight(&u[1 + w], n, 2, false, offset);
  }
  // u: volume fractions in a 3x3x3 stencil
  // n: guess for normal, updated if heights give steeper estimate
  static void GetNormalHeight(const std::array<Scal, 27>& u, Vect3& n) {
    const int w = 3;
    const int offset[] = {1, w, w * w};
    UpdateNormalHeight(&u[1 + w + w * w], n, 3, false, offset);
  }
  // u: volume fractions in a 3x3x3x3 stencil
  // n: guess for normal, updated if heights give steeper estimate
  static void GetNormalHeight(const std::array<Scal, 81>&, Vect4&) {
    fassert(false, "Not implemented");
  }
};

template <class M_>
void UNormal<M_>::CalcNormal(
    M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci, size_t edim,
    FieldCell<Vect>& fcn) {
  Imp::CalcNormal(m, fcu, fci, edim, fcn);
}

template <class M_>
void UNormal<M_>::CalcNormalYoungs(
    M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
    FieldCell<Vect>& fcn) {
  Imp::CalcNormalYoungs1(m, fcu, fci, fcn);
}

template <class M_>
auto UNormal<M_>::GetNormalYoungs(const std::array<Scal, 9>& u) -> Vect2 {
  return Imp::GetNormalYoungs(u);
}

template <class M_>
auto UNormal<M_>::GetNormalYoungs(const std::array<Scal, 27>& u) -> Vect3 {
  return Imp::GetNormalYoungs(u);
}

template <class M_>
auto UNormal<M_>::GetNormalYoungs(const std::array<Scal, 81>& u) -> Vect4 {
  return Imp::GetNormalYoungs(u);
}

template <class M_>
void UNormal<M_>::GetNormalHeight(const std::array<Scal, 9>& u, Vect2& n) {
  return Imp::GetNormalHeight(u, n);
}

template <class M_>
void UNormal<M_>::GetNormalHeight(const std::array<Scal, 27>& u, Vect3& n) {
  return Imp::GetNormalHeight(u, n);
}

template <class M_>
void UNormal<M_>::GetNormalHeight(const std::array<Scal, 81>& u, Vect4& n) {
  return Imp::GetNormalHeight(u, n);
}
